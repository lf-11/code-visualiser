<!-- Generated by SpecStory -->

# Build experimental workflow for parse button (2025-09-16 10:41Z)

_**User (2025-09-16 16:34Z)**_

See attached info. I would now like to add this workflow view. Let us start by building an experimental workflow.py file. Once everything works there, we can add to my app and the frontend. The idea is this: From the buttons in the frontend (index.html file), find those that trigger a js function, or do something. Example: There is this button in my index.html. In my db for the index.html file there is a ui_element entry whose content is this "<button id="parse-project-btn" class="hidden">Parse Project</button>". So then for each of these, the code should look if they trigger a js function, in a js file. In this case, it is defined as dom element in my app.js and is used like this in app.js: "elements.parseBtn.addEventListener('click', parseProject);". Then the parseProject function is called, this again calls endpoints from my fastapi server. Event listeners and dom elements exist as single entries in my db. functions as well. js functions have any api calls they make stored in their metadata "{
  "api_calls": [
    {
      "path": "/api/projects/parse",
      "method": "POST",
      "library": "fetch"
    }
  ]
}". So if we look for that path (or better path and method), in the content column again, we will find this python function "@router.get("/projects/{project_name}/parsing_status", response_model=List[File])
async def get_project_parsing_status(project_name: str):
    """
    Checks all files in a project for unparsed lines of code using the
    content stored in the database at parse time.
    """
    unparsed_files: List[File] = []
    with get_db_connection() as conn:
        with conn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cur:
            # 1. Get Project ID
            cur.execute("SELECT id FROM projects WHERE name = %s", (project_name,))
            project_row = cur.fetchone()
            if not project_row:
                raise HTTPException(status_code=404, detail=f"Project '{project_name}' not found.")
            project_id = project_row['id']

            # 2. Get all files and all elements for the project
            cur.execute("SELECT id, path, content FROM files WHERE project_id = %s AND is_latest = TRUE", (project_id,))
            files = cur.fetchall()
            
            file_ids = [f['id'] for f in files]
            if not file_ids:
                return []

            cur.execute(
                "SELECT file_id, start_line, end_line FROM code_elements WHERE file_id = ANY(%s) AND is_latest = TRUE",
                (file_ids,)
            )
            elements = cur.fetchall()

            # 3. Group elements by file for efficient lookup
            elements_by_file = {}
            for el in elements:
                if el['file_id'] not in elements_by_file:
                    elements_by_file[el['file_id']] = []
                elements_by_file[el['file_id']].append(el)

            # 4. Perform the check for each file
            for file_row in files:
                file_id = file_row['id']
                content = file_row['content'] or ''
                file_elements = elements_by_file.get(file_id, [])
                
                covered_lines = set()
                for el in file_elements:
                    for i in range(el['start_line'], el['end_line'] + 1):
                        covered_lines.add(i)
                
                content_lines = content.splitlines()
                is_unparsed = False
                for i, line_text in enumerate(content_lines, 1):
                    if line_text.strip() and i not in covered_lines:
                        is_unparsed = True
                        break
                
                if is_unparsed:
                    unparsed_files.append(File(id=file_id, path=file_row['path']))

    return sorted(unparsed_files, key=lambda f: f.path)", then gets its function etc. Build an mvp standalone code snippet that does this please and prints out the workflow it has found. Log what it is searching for at each step, then at the end give summary of workflow found and what elements it includes. Only do it for the parse button for now

---

_**Assistant**_

<think><details><summary>Thought Process</summary>**Considering Workflow Tracing Design**

I'm focusing on the UI element interaction, figuring out how to begin tracing from an HTML element. My current thought is on how to identify the Javascript function triggered by that element. Thinking about parsing the HTML structure and event listeners.


**Defining Code Relationships**

I've shifted my focus to the database, seeing how UI elements, JavaScript functions, and API calls are connected within it. I am now considering how to trace from the UI element, through its Javascript event listener, and finally to the backend API endpoint using the database metadata. The `code_elements` table looks promising.


**Developing Core Functionality**

I'm now focusing on the SQL queries needed to traverse the code. Specifically, I'm drafting queries that start with the UI element in `index.html` and trace its ID through the event listeners in JavaScript files. I'm considering how to best leverage the `code_elements` table and its `content` field to locate the relevant elements and relationships. The next step involves tracing into the associated API calls.


**Refining the Query Logic**

I'm now building the SQL queries to trace the workflow. Focusing on finding the `file_id` for `index.html` using the `projects` and `files` tables. After that, I'll search for the button element. Then, using the button's ID, search in the JavaScript files for the event listener.


**Outlining Script Structure**

I'm now outlining the structure of `workflow.py`. I'll begin with database connection, incorporating the reusable logic. The script will start by querying for the UI element, and I plan to hardcode the initial search for the button element and its ID. Subsequent steps will dynamically query for related elements, event listeners, and API calls, building upon the initial hardcoded starting point.


**Drafting the Python Script**

I'm now sketching out the `workflow.py` script. The plan is to modularize the code, with functions for each tracing step. I'll start with database connection and hardcode the initial UI element search, focusing on the "Parse Project" button. SQL query construction is the immediate next task.


**Designing SQL Queries**

I'm now focused on crafting the SQL queries. I've started with queries to locate the UI element and its DOM reference. The next phase will be to identify the event listeners linked to that element. I'm constructing queries to pinpoint the javascript functions and extract associated metadata.


**Defining SQL Queries**

I'm now focused on formulating the SQL queries for the `workflow.py` script. I've defined queries to locate the UI button element, its DOM reference in JavaScript, and the associated event listener. The next step involves crafting a query to pinpoint the JavaScript function, extracting its API call details from the metadata, and then building the final query to identify the corresponding backend Python function.


**Defining Initial SQL Queries**

I'm now working on the SQL queries for the `workflow.py` script. I've got queries planned to locate the UI button element, its associated DOM reference, and the corresponding event listener. The next step involves crafting a query to find the JavaScript function, extracting its API call details from the metadata. From there, I'll build the final query to pinpoint the backend Python function associated with the API call.


**Designing the Python Script**

I'm now working on the Python script, preparing to implement the database connection using the provided configuration details. The core structure will consist of functions for each step: finding the UI element, the Javascript event listener, the Javascript function, and the backend API function. Initial focus will be on establishing a successful database connection.


**Designing the Initial Queries**

I'm now working on the foundational SQL queries. My plan is to first locate the UI element using its ID. Then, I'll trace it to the associated DOM reference in JavaScript files using a series of carefully constructed queries. The next step is to identify the event listener, enabling me to extract the linked Javascript function.


**Outlining Script Queries**

I'm now focusing on the SQL queries needed for each step of the script. I've outlined the initial queries to locate the button, DOM reference, event listener, Javascript function and API details, and finally the backend Python function. I will create the `workflow.py` file and copy the DB connection logic.


**Building the Core Script**

I'm now working on the basic Python script structure. I've included database connection details and started defining functions for each tracing stage. The script will initiate by searching for the UI element, specifically focusing on the "Parse Project" button. I am constructing queries using SQL to make the script fully functional.


**Developing Script Queries**

I'm now implementing the SQL queries for the `workflow.py` script. The initial queries aim to locate the UI button, the DOM reference within JavaScript, and the corresponding event listener. The next phase involves crafting a query to pinpoint the JavaScript function and extract the API call details from its metadata.


**Tracing and Script Implementation**

I'm now implementing the SQL queries to construct the core functionality.  My focus is on creating the foundational Python functions and integrating the database connection for the "Parse Project" button workflow. The queries for finding the DOM reference and event listener are currently under development.


</details></think>

---

Of course. I will now create the `workflow.py` file to trace the workflow, starting from the "Parse Project" button. This script will connect to your database, trace the connections from the HTML button to the Javascript function and then to the backend API endpoint, and print out the discovered workflow.

First, I will create the `workflow.py` file.

---

